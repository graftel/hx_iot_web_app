
<h2 class="chart-heading">Overall Heat Transfer Rate</h2>
<div width="1000" height="600" class="row">
	<svg id="visualisation" width="800" height="500" class="col col-md-5"></svg>
	<table class="table col col-md-4" id="legend"></table>
</div>

<style>
div.tooltip {
	position: absolute;
	text-align: center;
	width: 130px;
	height: 32px;
	padding: 2px;
	font: 12px sans-serif;
	background: lightsteelblue;
	border: 0px;
	border-radius: 8px;
	pointer-events: none;
}

path.line {
	width: 580px;
	height: 351px;
	overflow: hidden;
}

#legend {
	font-weight: bold;
	font-size: 20px;
	font-style: oblique;
	cursor: pointer;
	width: 40%;
	margin-top: 3%;
}

#legend td {
	text-align: center;
}

#legend td:hover {
	background-color: #f5f5f5;
}

.disable {
	pointer-events: none;
	background-color: #e6e6e6;
}
</style>
<script src="js/d3.min.js"></script>
<script src="vendor/jquery/jquery.min.js"></script>

<script>
	var colors = {};
	var vis = d3.select("#visualisation"), WIDTH = 700, HEIGHT = 400, MARGINS = {
		top : 20,
		right : 20,
		bottom : 20,
		left : 50
	};
	var minX = -1, maxX = -1, minY = -1, maxY = -1;
	var data = <%-JSON.stringify(data)%>;
	var counter = parseInt(<%-JSON.stringify(counter)%>);
	var graphData = data;
	var res = reformatData(data);
	var legendSpace = WIDTH/graphData.length; // spacing for the legend
		setMinMaxforAxis(graphData);
	var zoom = d3.zoom().on("zoom", zoomFunction);
	var assets = <%- JSON.stringify(assets) %>;
	var xScale = d3.scaleLinear()
			.range([ MARGINS.left, WIDTH - MARGINS.right - 50 ]).domain(
					[ minX, maxX ]);
	var yScale = d3.scaleLinear().range(
			[ HEIGHT - MARGINS.top, MARGINS.bottom ]).domain([ minY - 0.2, maxY + 0.2 ]);

	var xAxis = d3.axisBottom(xScale).ticks(10).tickFormat(function(d){ return timestampToTime(d); });
	var yAxis = d3.axisLeft(yScale);

	var gX = vis.append("g").attr("class", "xaxis").attr("transform",
			"translate(0," + (HEIGHT - MARGINS.bottom) + ")").call(xAxis).selectAll("text")
		    .attr("y", 0)
		    .attr("x", 9)
		    .attr("dy", ".35em")
		    .attr("transform", "rotate(90)")
		    .style("text-anchor", "start");

	var gY = vis.append("g").attr("class", "yaxis")
			.attr("transform", "translate(" + (MARGINS.left) + ",0)").call(
					yAxis);
	var tip = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);
	
	var view = vis
	//  .attr("class", "zoom")
//	  .attr("width", 300)
	//  .attr("height", 300)
	  .call(zoom);
	assignColor();

	var dataGroup = res;	
	var lineGen = d3.line()
	  .x(function(d) {
	    return xScale(d.xV);
	  })
	  .y(function(d) {
	    return yScale(d.yV);
	  });

	dataGroup.forEach(function(d, i) {
        d3.select("#legend").append(function(){
        	if(i%5 == 0){
        		d3.select("#legend").append("tr");
        	}
        	return "td";
        }(i)).text(d.key).attr("class", "legend showLine")
        .style("color", function() { return colors[d.key]; })
      	.on("click", function(){
            var device = $(this).text();
            $(this).toggleClass("showLine");
            setStrokeVisibility(device);
        });
        
        setLegendEnability(d.key,d.values.length);
        
		vis.append('path')
	        .attr('d', lineGen(d.values))
	        .attr('stroke', colors[d.key])
	        .attr('stroke-width', 2)
	        .attr('class', 'line')
	        .attr('fill', 'none')
	        .attr('id',d.key)
	        .on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
	});
	function zoomFunction(){
		  var new_xScale = d3.event.transform.rescaleX(xScale);
		  var new_yScale = d3.event.transform.rescaleY(yScale);			
		  gX.call(xAxis.scale(new_xScale));
		  gY.call(yAxis.scale(new_yScale));
		  vis.selectAll('.line').attr("transform", d3.event.transform);
	}
	
	function handleMouseOver() {
		var xValue = timestampToTime(Math.round(xScale.invert(d3.mouse(this)[0])));
		var yValue = yScale.invert(d3.mouse(this)[1]);
		tip.transition()		
        .duration(200)		
        .style("opacity", .9);		
		
    	tip.html(xValue + "<br/>"  + yValue)	
        .style("left", (d3.event.pageX) + "px")		
        .style("top", (d3.event.pageY - 28) + "px");	
	}
	
	function handleMouseOut(){
		tip.transition()		
        .duration(200)		
        .style("opacity", 0)
        .style("pointer-events", 'none');
	}
	
	function updateGraph(data) {
		data = JSON.parse(data);
		setMinMaxforAxis(data);
		res = reformatData(data);
		res.forEach(function(d){
			dataGroup.unshift(d);
		});
		
		xScale.domain([minX , maxX]);
		yScale.domain([ minY - 0.5, maxY + 0.5 ]);
		vis.select(".xaxis").remove();
		vis.select(".yaxis").remove();
		vis.selectAll(".line").remove();

	    gY = vis.append("g").attr("class", "yaxis")
			.attr("transform", "translate(" + (MARGINS.left) + ",0)").call(yAxis);
		gX = vis.append("g").attr("transform",
			"translate(0," + (HEIGHT - MARGINS.bottom) + ")").attr("class","xaxis").call(xAxis).selectAll("text")
			.attr("y", 0)
			.attr("x", 9)
			.attr("dy", ".35em")
			.attr("transform", "rotate(90)")
			.style("text-anchor", "start");
		console.log(dataGroup);
	    dataGroup.forEach(function(d, i) {
		   var ele =  vis.append('path')
		        .attr('d', lineGen(d.values))
		        .attr('stroke', colors[d.key])
		        .attr('stroke-width', 2)
		        .attr('class', 'line')
		        .attr('fill', 'none')
		        .attr('id', d.key)
		        .on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
	
		    setStrokeVisibility(d.key);
		    setLegendEnability(d.key,d.values.length);
		});
	}

	function setStrokeVisibility(key){
		if($("td:contains('"+key+"')" ).hasClass("showLine"))
			$("#"+key).show();
		else
			$("#"+key).hide();
	}
	
	function setLegendEnability(key,itemsLength){
		if(itemsLength == 0)
        	$("td:contains('"+key+"')" ).addClass("disable");
        else
        	$("td:contains('"+key+"')" ).removeClass("disable");	
	}
	
	function assignColor(){
		var assets = <%-JSON.stringify(assets)%>;
		Object.keys(assets).forEach(function(key){
			colors[key] = getRandomColor();	
		});		
	}
	
	function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
	
	function timestampToTime(timestamp){
		var date = new Date(timestamp*1000);
		var hours = date.getHours();
		var minutes = "0" + date.getMinutes();
		var seconds = "0" + date.getSeconds();
		return hours + ':' + minutes.substr(-2) + ':' + seconds.substr(-2);
	}
	
	function setMinMaxforAxis(data){
		var tempX = [], tempY = [];
		tempX = data.reduce(function(a,b) {  var vals = Object.values(b)[0]; var i = vals.map(function(x){ return(x.EpochTimeStamp); });  return a.concat(i); }, [])
		tempY = data.reduce(function(a,b) {  var vals = Object.values(b)[0]; var i = vals.map(function(x){ if(x["Heat_Balance_Error(%)"] != 999) return(x["Heat_Balance_Error(%)"]); });  return a.concat(i); }, [])
		if(tempX.length == 0 && tempY == 0)
			return;
		minX = Math.min.apply(Math,tempX);
		maxX = Math.max.apply(Math,tempX);
		minY = Math.min.apply(Math,tempY);
		maxY = Math.max.apply(Math,tempY);
	}
	
	function reformatData(data){
		var res = [];
		for(a in data){
			var grp = {};
			var key = Object.keys(data[a])[0];
			grp["key"] = key;
			grp["values"] = new Array();
			var t =  data[a][key];
			for(b in t){
				grp["values"].push({ "xV": t[b]["EpochTimeStamp"], "yV": t[b]["Heat_Balance_Error(%)"], "new": true });
			}
			res.push(grp);
		}
		return res;
	}
</script>
