
<h2 class="chart-heading">Overall Heat Transfer Rate</h2>
<div width="1000" height="600" class="row">
	<svg id="visualisation" width="1000" height="600"
		class="col col-md-9 col-md-offset-3"></svg>
</div>
<!-- <div class="row">
	<table class="table col col-md-9 col-md-offset-3" id="legend"></table>
</div> -->

<style>
/* div.tooltip {
	position: absolute;
	text-align: center;
	width: 130px;
	height: 32px;
	padding: 2px;
	font: 12px sans-serif;
	background: lightsteelblue;
	border: 0px;
	border-radius: 8px;
	pointer-events: none;
}
 */
.xaxis text, .yaxis text {
	color: black;
	font-size: 150%;
}

path.line {
	width: 580px;
	height: 351px;
	overflow: hidden;
}

.sideLegend text {
	font-weight: bold;
	font-size: 15px;
	cursor: pointer;
}

/* #legend {
	font-weight: bold;
	font-size: 20px;
	font-style: oblique;
	cursor: pointer;
	width: 40%;
}

#legend td {
	text-align: center;
}

#legend td:hover {
	background-color: #f5f5f5;
}
 */
.disable {
	pointer-events: none;
	background-color: #e6e6e6;
}
</style>
<script src="js/d3.min.js"></script>
<script src="vendor/jquery/jquery.min.js"></script>

<script>
	var colors = {};
	var minX = -1, maxX = -1, minY = -1, maxY = -1;

	var vis = d3.select("#visualisation"), WIDTH = 700, HEIGHT = 400, MARGINS = {
		top : 20,
		right : 20,
		bottom : 20,
		left : 50
	};
	var data = <%-JSON.stringify(data)%>;
	var assets = <%- JSON.stringify(assets) %>;
	var res = reformatData(data);

	setMinMaxforAxis(data);

	//var legendSpace = WIDTH/data.length; // spacing for the legend
	var zoom = d3.zoom().scaleExtent([ 0.5, 2 ]).on("zoom", zoomFunction);

	var xScale = d3.scaleLinear().range(
			[ MARGINS.left, WIDTH - MARGINS.right - 50 ])
			.domain([ minX, maxX ]);
	var yScale = d3.scaleLinear().range(
			[ HEIGHT - MARGINS.top, MARGINS.bottom ]).domain(
			[ minY - 0.2, maxY + 0.2 ]);

	var xAxis = d3.axisBottom(xScale).ticks(10).tickFormat(function(d) {
		return timestampToTime(d);
	});
	var yAxis = d3.axisLeft(yScale);

	var gX = vis.append("g").attr("class", "xaxis").attr("transform",
			"translate(0," + (HEIGHT - MARGINS.bottom) + ")");

	gX.call(xAxis).selectAll("text").attr("y", 0).attr("x", 9).attr("dy",
			".35em").attr("transform", "rotate(90)").style("text-anchor",
			"start");

	var gY = vis.append("g").attr("class", "yaxis").attr("transform",
			"translate(" + (MARGINS.left) + ",0)").call(yAxis);
	var sideLegend = vis.append('g').attr('class', 'sideLegend');

	/*var tip = d3.select("body").append("div")	
	.attr("class", "tooltip")				
	.style("opacity", 0);*/

	vis.append("defs").append("clipPath").attr("id", "clip").append("rect")
			.attr("x", "50").attr("y", "-20").attr("width", WIDTH - 120).attr(
					"height", HEIGHT);

	var view = vis
	//	 .attr("class", "zoom")
	.attr("x", 9).attr("y", 0).attr("width", WIDTH - 50).attr("height",
			HEIGHT + 50).call(zoom);
	var chartBody = vis.append("g").attr("clip-path", "url(#clip)");

	assignColor();

	var dataGroup = res;
	var lineGen = d3.line().x(function(d) {
		return xScale(d.xV);
	}).y(function(d) {
		return yScale(d.yV);
	});

	dataGroup.forEach(function(d, i) {

		sideLegend.append('rect').attr('x', WIDTH - 20).attr('y', function() {
			return (i * 20) + 10;
		}).attr('width', 10).attr('height', 10).style('fill', function() {
			return colors[d.key];
		});

		sideLegend.append('text').attr('x', WIDTH - 8).attr('y', function() {
			return (i * 20) + 20;
		}).attr("class", "showLine").attr("data-id", d.key).text(function() {
			return assets[d.key];
		}).on("click", function() {
			var device = $(this).attr("data-id");
			$(this).toggleClass("showLine");
			setStrokeVisibility(device);
		});
		/*   d3.select("#legend").append(function(){
		  	if(i%5 == 0){
		  		d3.select("#legend").append("tr");
		  	}
		  	return "td";
		  }(i)).text(d.key).attr("class", "legend showLine")
		  .style("color", function() { return colors[d.key]; })
			.on("click", function(){
		      var device = $(this).text();
		      $(this).toggleClass("showLine");
		      setStrokeVisibility(device);
		  });
		 */
		setLegendEnability(d.key, d.values.length);

		chartBody.append('path').attr('d', lineGen(d.values)).attr('stroke',
				colors[d.key]).attr('stroke-width', 2).attr('class', 'line')
				.attr('fill', 'none').attr('id', d.key);
		//   .on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
	});

	// mouse over event - start
	var mouseG = vis.append("g").attr("class", "mouse-over-effects");

	mouseG.append("path") // this is the black vertical line to follow mouse
	.attr("class", "mouse-line").style("stroke", "black").style("stroke-width",
			"1px").style("opacity", "0");

	var lines = document.getElementsByClassName('line');

	var mousePerLine = mouseG.selectAll('.mouse-per-line').data(data).enter()
			.append("g").attr("class", "mouse-per-line");

	mousePerLine.append("circle").attr("r", 7).style("stroke", "red").style(
			"fill", "none").style("stroke-width", "1px").style("opacity", "0");

	mousePerLine.append("text").attr("transform", "translate(10,3)");

	mouseG
			.append('svg:rect')
			// append a rect to catch mouse movements on canvas
			.attr("x", "50")
			.attr("y", "30")
			.attr('width', WIDTH - 120)
			// can't catch mouse events on a g element
			.attr('height', HEIGHT - 50)
			.attr('fill', 'none')
			.attr('pointer-events', 'all')
			.on('mouseout', function() { // on mouse out hide line, circles and text
				d3.select(".mouse-line").style("opacity", "0");
				d3.selectAll(".mouse-per-line circle").style("opacity", "0");
				d3.selectAll(".mouse-per-line text").style("opacity", "0");
			})
			.on('mouseover', function() { // on mouse in show line, circles and text
				d3.select(".mouse-line").style("opacity", "1");
				d3.selectAll(".mouse-per-line circle").style("opacity", "1");
				d3.selectAll(".mouse-per-line text").style("opacity", "1");
			})
			.on(
					'mousemove',
					function() { // mouse moving over canvas
						var mouse = d3.mouse(this);
						d3.select(".mouse-line").attr("d", function() {
							var d = "M" + mouse[0] + "," + HEIGHT;
							d += " " + mouse[0] + "," + 0;
							return d;
						});

						d3
								.selectAll(".mouse-per-line")
								.attr(
										"transform",
										function(d, i) {

											var key = Object.keys(d)[0];
											if (!($(".sideLegend text[data-id*='"
													+ key + "']")
													.hasClass("showLine")))
												return null;

											var xDate = xScale.invert(mouse[0]), bisect = d3
													.bisector(function(d) {
														return key;
													}).right;
											idx = bisect(d[key], xDate);

											var beginning = 0, end = lines[i]
													.getTotalLength(), target = null;

											while (true) {
												target = Math
														.floor((beginning + end) / 2);
												pos = lines[i]
														.getPointAtLength(target);
												if ((target === end || target === beginning)
														&& pos.x !== mouse[0]) {
													break;
												}
												if (pos.x > mouse[0])
													end = target;
												else if (pos.x < mouse[0])
													beginning = target;
												else
													break; //position found
											}
											d3
													.select(this)
													.select('text')
													.text(
															yScale
																	.invert(
																			pos.y)
																	.toFixed(2));

											return "translate(" + mouse[0]
													+ "," + pos.y + ")";
										});
					});
	//mouse over event - end

	// update live graph
	function updateGraph(data) {
		data = JSON.parse(data);
		setMinMaxforAxis(data);
		res = reformatData(data);
		res.forEach(function(d) {
			dataGroup.unshift(d);
		});

		vis.select(".xaxis").remove();
		vis.select(".yaxis").remove();
		chartBody.selectAll(".line").remove();

		xScale.domain([ minX, maxX ]);
		yScale.domain([ minY - 0.5, maxY + 0.5 ]);

		xAxis = d3.axisBottom(xScale).ticks(10).tickFormat(function(d) {
			return timestampToTime(d);
		});
		yAxis = d3.axisLeft(yScale);

		gY = vis.append("g").attr("class", "yaxis").attr("transform",
				"translate(" + (MARGINS.left) + ",0)").call(yAxis);
		gX = vis.append("g").attr("transform",
				"translate(0," + (HEIGHT - MARGINS.bottom) + ")").attr("class",
				"xaxis");

		gX.call(xAxis).selectAll("text").attr("y", 0).attr("x", 9).attr("dy",
				".35em").attr("transform", "rotate(90)").style("text-anchor",
				"start");

		dataGroup.forEach(function(d, i) {
			chartBody.append('path').attr('d', lineGen(d.values)).attr(
					'stroke', colors[d.key]).attr('stroke-width', 2).attr(
					'class', 'line').attr('fill', 'none').attr('id', d.key);
			//  .on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
			setStrokeVisibility(d.key);
			setLegendEnability(d.key, d.values.length);
		});
	}

	// helper functions
	function zoomFunction() {
		var new_xScale = d3.event.transform.rescaleX(xScale);
		var new_yScale = d3.event.transform.rescaleY(yScale);
		gX.call(xAxis.scale(new_xScale)).selectAll("text").attr("y", 0).attr(
				"x", 9).attr("dy", ".35em").attr("transform", "rotate(90)")
				.style("text-anchor", "start");
		gY.call(yAxis.scale(new_yScale));
		vis.selectAll('.line').attr("transform", d3.event.transform);
	}

	/*	function handleMouseOver() {
	 var xValue = timestampToTime(Math.round(xScale.invert(d3.mouse(this)[0])));
	 var yValue = yScale.invert(d3.mouse(this)[1]).toFixed(2);
	 tip.transition()		
	 .duration(200)		
	 .style("opacity", .9);		
	
	 tip.html(xValue + "<br/>"  + yValue)	
	 .style("left", (d3.event.pageX) + "px")		
	 .style("top", (d3.event.pageY - 28) + "px");	
	 }
	
	 function handleMouseOut(){
	 tip.transition()		
	 .duration(200)		
	 .style("opacity", 0)
	 .style("pointer-events", 'none');
	 }*/

	function setStrokeVisibility(key) {
		if ($(".sideLegend text[data-id*='" + key + "']").hasClass("showLine"))
			d3.selectAll("#" + key).style("opacity", 1);
		else
			d3.selectAll("#" + key).style("opacity", 0);
	}

	function setLegendEnability(key, itemsLength) {
		if (itemsLength == 0)
			$(".sideLegend text[data-id*='" + key + "']").addClass("disable");
		else
			$(".sideLegend text[data-id*='" + key + "']")
					.removeClass("disable");
	}

	function assignColor() {
		var assets = <%-JSON.stringify(assets)%>;
		Object.keys(assets).forEach(function(key) {
			colors[key] = getRandomColor();
		});
	}

	function getRandomColor() {
		var letters = '0123456789ABCDEF';
		var color = '#';
		for (var i = 0; i < 6; i++) {
			color += letters[Math.floor(Math.random() * 16)];
		}
		return color;
	}

	function timestampToTime(timestamp) {
		var date = new Date(timestamp * 1000);
		var hours = date.getHours();
		var minutes = "0" + date.getMinutes();
		return hours + ':' + minutes.substr(-2);
	}

	function setMinMaxforAxis(data) {
		var tempX = [], tempY = [];
		tempX = data.reduce(function(a, b) {
			var vals = Object.values(b)[0];
			var i = vals.map(function(x) {
				return (x.EpochTimeStamp);
			});
			return a.concat(i);
		}, [])
		tempY = data.reduce(function(a, b) {
			var vals = Object.values(b)[0];
			var i = vals.map(function(x) {
				if (x["Heat_Balance_Error(%)"] != 999)
					return (x["Heat_Balance_Error(%)"]);
			});
			return a.concat(i);
		}, [])
		if (tempX.length == 0 && tempY == 0)
			return;
		minX = Math.min.apply(Math, tempX);
		maxX = Math.max.apply(Math, tempX);
		minY = Math.min.apply(Math, tempY);
		maxY = Math.max.apply(Math, tempY);
	}

	function reformatData(data) {
		var res = [];
		for (a in data) {
			var grp = {};
			var key = Object.keys(data[a])[0];
			grp["key"] = key;
			grp["values"] = new Array();
			var t = data[a][key];
			for (b in t) {
				grp["values"].push({
					"xV" : t[b]["EpochTimeStamp"],
					"yV" : t[b]["Heat_Balance_Error(%)"]
				});
			}
			res.push(grp);
		}
		return res;
	}
</script>
